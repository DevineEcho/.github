# DEVINE ECHO
***
**DevineEcho**는 React + Pixi.js + Spring Boot + MySQL을 활용한 Vampire Survivor 스타일의 2D 웹 게임 프로젝트입니다.
***

#  🎮 개발 동기
AnimalWar라는 게임의 5인 팀프로젝트를 진행하며 협업을 경험하였지만,
1인 프로젝트를 통해 게임 개발의 전체적인 과정을 직접 설계하고 구현하는 경험을 가지고 싶었습니다. 
신입 백엔드 개발자로서 Spring Boot와 MySQL 기반의 Restful API 설계, JWT 인증시스템, 게임데이터 저장 및 처리 로직 등 
실무에서 사용되는 기술들로 프로젝트를 완성하는 것이 목표였습니다. 
단순한 게임 플레이뿐만 아니라, 인벤토리 및 상점 시스템, 스킬 시스템 등으로 백엔드 아키텍쳐를 설계하며 실무 감각을 키우고 싶었습니다.

***

#  🏹 프로젝트 개요

- **장르:** 액션 로그라이크 (Vampire Survivors 스타일)  
- **게임 스토리:**  
  죽음의 천사 **아즈라엘**은 악마들과의 대전쟁을 앞두고, 우연히 **니자**라는 악마와 조우한다.  
  니자는 아즈라엘에게 의미심장한 경고를 남긴다.  

  > *"너의 이름처럼, 결국 네 자신이 죽음으로 구렁텅이에 빠질 것이다."*  

  전쟁이 시작되고, 아즈라엘은 무자비하게 악마들을 처단하기 시작한다.  
  수백, 수천의 악마를 베어 넘기는 동안, 점차 이상한 감각에 빠져든다.  
  어느 순간, 자신이 상대하는 **악마들의 모습이 동료 천사들처럼 보이기 시작한 것**이다.  

  전쟁의 막바지, 아즈라엘은 결국 깨닫게 된다.  
  **이것은 단순한 환각이 아니라, 현실이었다는 것을.**  
  니자와 처음 마주했을 때, 그는 환각술을 걸었고, 그 이후로 아즈라엘은  
  **악마가 아니라 동료 천사들을 베어 온 것**이었다.  
  자신이 배신자가 되어버렸음을 깨달은 순간, 아즈라엘은 깊은 절망에 빠지는데…  

- **게임 특징:**  
  - 뱀파이어서바이벌, 리그오브레전드 집중포화, 탕탕특공대와 비슷한 **'뱀서라이크'** 게임
  - 플레이어만 레벨업 하는 것이 아니라, 적도 함께 성장하는 **적 스킬 강화 시스템** 구현하여 **전락젹 플레이 유도** 
  - **반복적인 로그라이크 게임의 지루함을 해소하기 위해 다양한 성장 요소 추가**  
    - 클리어 보상으로 획득한 재화를 사용해 **새로운 스킬**을 구매 가능  
    - **스킨 시스템**을 통해 캐릭터 외형 및 스킬 이펙트 변경 가능  


***


# 🎥 게임영상
[![Gameplay Video](https://img.youtube.com/vi/비디오ID/0.jpg)](https://www.youtube.com/watch?v=비디오ID)
준비중. 업데이트 예정


***

# 🛠️ 기술 스택


### **Frontend**
![Java Script](https://img.shields.io/badge/Java%20Script-F7DF1E?style=flat&logo=javascript&logoColor=black) ![React](https://img.shields.io/badge/React-61DAFB?style=flat&logo=React&logoColor=white) ![React Router](https://img.shields.io/badge/React%20Router-CA4245?style=flat&logo=reactrouter&logoColor=white)
![Pixi.js](https://img.shields.io/badge/Pixi.js-F43059?style=flat&logo=pixijs&logoColor=white) ![HTML](https://img.shields.io/badge/HTML-E34F26?style=flat&logo=html5&logoColor=white) ![CSS](https://img.shields.io/badge/CSS-1572B6?style=flat&logo=css3&logoColor=white) ![KAKAO OAUTH API](https://img.shields.io/badge/Kakao%20OAtuh%20API-FFCD00?style=flat&logo=kakao&logoColor=black)


### **Backend**
![Java](https://img.shields.io/badge/Java-FF7700?style=flat) ![Spring Boot](https://img.shields.io/badge/Spring%20Boot-6DB33F?style=flat&logo=springboot&logoColor=white) ![Spring Security](https://img.shields.io/badge/Spring%20Security-6DB33F?style=flat&logo=springsecurity&logoColor=white) ![Spring Framework](https://img.shields.io/badge/Spring%20Framework-6DB33F?style=flat&logo=spring&logoColor=white) ![Spring Data JPA](https://img.shields.io/badge/Spring%20Data%20JPA-6DB33F?style=flat&logo=spring&logoColor=white) ![Spring MVC](https://img.shields.io/badge/Spring%20MVC-6DB33F?style=flat&logo=spring&logoColor=white)
![Hibernate](https://img.shields.io/badge/Hibernate-59666C?style=flat&logo=hibernate&logoColor=white) ![Gradle](https://img.shields.io/badge/Gradle-02303A?style=flat&logo=gradle&logoColor=white) ![Lombok](https://img.shields.io/badge/Lombok-0078D3?style=flat) ![Apache Tomcat](https://img.shields.io/badge/Apache%20Tomcat-F8DC75?style=flat&logo=apachetomcat&logoColor=black) ![MySQL](https://img.shields.io/badge/MySQL-4479A1?style=flat&logo=mysql&logoColor=white) ![JWT](https://img.shields.io/badge/JWT-000000?style=flat&logo=jsonwebtokens&logoColor=white) 

### **DevOps & Tools**
![GitHub](https://img.shields.io/badge/GitHub-181717?style=flat&logo=github&logoColor=white) ![IntelliJ IDEA](https://img.shields.io/badge/IntelliJ%20IDEA-000000?style=flat&logo=intellij-idea&logoColor=white) ![Visual Studio Code](https://img.shields.io/badge/Visual%20Studio%20Code-394EFF?style=flat) ![Postman](https://img.shields.io/badge/Postman-FF6C37?style=flat&logo=postman&logoColor=black)


***


# 📂 레포지터리
- [Frontend (React + Pixi.js)](https://github.com/DevineEcho/devineecho_front)
- [Backend (Spring Boot + MySQL)](https://github.com/DevineEcho/devineecho_backend)

 
***


# **⚔️ 주요 기능**


#### **1️⃣ 개발과 운영**
- **MySQL DB**: 플레이어, 아이템, 스킬 데이터를 저장하고 관리  
- **Spring Boot & JPA**: 엔티티 설계 및 DB 연동, 데이터 일관성 유지  
- **Gradle**: 의존성 관리 및 프로젝트 빌드  


#### **2️⃣ 사용자 관리 및 인증**
- **회원가입**: Spring Security를 이용한 비밀번호 암호화 (Bcrypt)  
- **JWT 인증**:  
  - 로그인 시 JWT 토큰 발급 (Authorization Header 사용)  
  - 토큰 만료 및 유효성 검증  
  - Stateless 서버 구조 구현  
- **Kakao OAuth API**: 카카오 로그인 기능을 통한 OAuth 인증 구현  


#### **3️⃣ 게임 데이터 관리 및 저장**
- **스테이지 데이터 저장**  
  - 스테이지 클리어 시 레벨, 경험치, 체력, 스킬 레벨 등을 DB에 저장  
  - 다음 접속 시 '이어하기' 기능 제공  
- **아이템 및 스킬 장착 시스템**  
  - 보유한 아이템 및 스킬을 필터링하여 인벤토리에 표시  
  - 장착 및 해제 시 DB에 반영 (현재 장착 가능한 스킬은 3개, 아이템 착용으로 인한 스탯 변동 기능은 미구현)  


#### **4️⃣ 게임 내 경제 시스템**
- **상점 시스템**  
  - 골드 또는 다이아몬드로 아이템 구매 가능  
  - 구매 시 DB에 반영하여 보유 재화 차감
  - 상점 UI에서 보유 중인 아이템 표시  


#### **5️⃣ 전투 시스템**
- **스킬 업그레이드 시스템**  
  - 적 처치 시 경험치 획득  
  - 레벨업 시 캐릭터 스킬 업그레이드 & 적 스킬 업그레이드 순차 진행  
  - 캐릭터 강화와 동시에 적의 능력치도 향상하여 난이도 조절과 전략적 플레이 유도
  - 스킬 업그레이드 정보는 프론트엔드에서 유지되며, 스테이지 클리어 후 DB에 반영
- **보스 시스템**  
  - 지속적으로 스폰되는 일반 몬스터 외에, 스테이지별 특정 시간에 보스 출현
- **체력 회복 시스템**  
  - 40초 간격으로 일정 체력을 회복시키는 '성배' 등장  
- **환각 시스템**  
  - 4스테이지 이후 일정 간격으로 적(악마)의 모습이 천사로 바뀌는 '환각' 시스템 적용  
- **피격 시스템**  
  - 적이 캐릭터 스킬에 맞을 경우 깜빡이는 피격 효과 적용 
  - 캐릭터가 적과 닿으면 붉게 변하는 피격 효과 & 무적 시간 부여
- **스테이지 시스템**  
  - 각 스테이지는 120초 후 자동 클리어
  - 스테이지가 높아질수록 적의 능력치 및 스폰 속도 증가


***


# **🔨 추가 개발 계획**


#### **🔧 게임 기능 개선**
- **신규 스킬 추가**: 더 다양한 전투 스타일을 위한 새로운 스킬 구현  
- **아이템 장착 시스템 확장**: 아이템 장착에 따른 능력치 변화, 스킬에 추가효과가 부여되도록 구현  
- **스킨 시스템 확장**: 캐릭터 외형 변경 기능, 스킨 장착 시 스킬 이펙트도 변경되도록 구현  
- **최종 스테이지 엔딩 구현**: 5스테이지 클리어 후 엔딩 연출 추가  
- **사망 시 게임 진행 선택**: 캐릭터 사망 후 '다시하기' 또는 '메인으로 돌아가기' 선택 가능  
- **이벤트 스테이지 추가**: 기존 5스테이지 이후 확장 가능한 이벤트 스테이지 도입 또는 스토리 확장  
- **미션 및 업적 시스템 추가**: 특정 조건을 달성하면 보상을 제공하는 업적 및 미션 기능 구현하여 플레이어의 지속적인 동기부여 유도  


#### **🚀 배포 및 성능 최적화**
- **AWS 배포**: AWS를 활용하여 서버 및 DB 배포  
- **도메인 연결**: 배포 후 도메인을 연결하여 웹에서 바로 플레이 가능하도록 설정
- **CI/CD 자동화**: GitHub Actions를 활용하여 빌드 및 배포 자동화  
- **API 최적화 및 트래픽 관리**: API 요청 최적화 및 캐싱 적용, 높은 트래픽에서도 원활한 게임 운영을 위한 로드 밸런싱 고려


***


# 🤔 개발 후기


### 🥇 WHY?
처음 이 게임을 기획하고 개발하려고 했을 때 가장 먼저 고민했던 것은 "어떤 기술 스택을 사용할 것인가?" 였다. 
기술 스택의 선택은 개발 속도뿐만 아니라 유지보수성과 확장성에도 큰 영향을 미치는 요소이기 때문이다.

백엔드에서는 Spring Boot를 선택했다. 기존에 사용해 본 경험이 있어 빠른 개발이 가능했고, Spring Security와 JWT를 활용한 인증 시스템을 구현하기에 적합했기 때문이다. 또한, 데이터 일관성을 유지하고 관리하기 위해 JPA를 사용했으며, RESTful API 설계를 통해 프론트엔드와의 원활한 데이터 교환을 목표로 했다. 데이터베이스는 MySQL을 사용했다. 플레이어, 아이템, 스킬 간의 관계가 복잡하게 얽혀 있는 만큼 관계형 데이터베이스가 적절하다고 판단했다. Redis와 같은 NoSQL을 사용하지 않은 이유는, 휘발성 저장 방식이기 때문에 스테이지 클리어 시 저장해야 하는 중요한 데이터가 손실될 위험이 있었기 때문이다.

프론트엔드는 React를 선택했다. React는 컴포넌트 기반의 구조로 UI를 재사용하기 쉽고, 상태 관리가 용이하여 게임과 같은 인터랙티브한 애플리케이션을 개발하기에 적합했다. 게임 개발 라이브러리로는 Pixi.js를 사용했다. Phaser.js와 비교했을 때, Pixi.js는 WebGL 기반으로 최적화가 잘 되어 있고, 불필요한 물리 엔진이나 씬 관리 기능이 없어 더 가볍고 유연한 개발이 가능했다. 특히 로그라이크 장르 특성상, 다수의 적과 스킬이 빠르게 화면에 등장하고 소멸하는데, Pixi.js의 고성능 렌더링이 이 요구 사항을 충족하는 데 유리했다.


### 🥈  SO ?
개발을 진행하면서 가장 크게 얻은 점은 프론트엔드와 백엔드의 흐름을 직접 설계하고 최적화하는 과정에서의 성장이었다. 1인 개발을 하면서 기획, 개발, UI 디자인, API 설계까지 전반적인 과정을 경험할 수 있었고, 단순히 기능을 구현하는 것이 아니라 “이 기능이 사용자의 경험을 어떻게 개선할 것인가?”를 고민하는 과정이었다. API 설계 시 프론트엔드가 원하는 데이터를 더 효율적으로 제공할 방법을 고민하며 데이터 흐름을 설계했고, 백엔드의 역할에 대한 이해도 더욱 깊어졌다. 
앞으로는 OAuth 로그인 로직을 개선하여 로그인 유지 기능을 추가하고, 스킬 및 아이템을 다양화하여 더 많은 플레이 스타일을 지원하며, 현재 5개의 스테이지에서 이벤트 스테이지와 챌린지 모드를 추가하는 등 게임의 완성도를 더욱 높일 계획이다. 또한, AWS 환경에서 CI/CD를 적용하여 지속적인 배포와 트래픽 관리까지 고려하는 단계로 확장할 것이며, 이를 통해 단순한 개발 경험을 넘어 실무적인 시스템 운영까지 경험해 보고자 한다. 


### 🥉 SERIOUS ?
물론 개발 과정에서 여러 어려움도 있었다. 가장 큰 문제 중 하나는 Kakao OAuth 로그인 구현 문제였다. API를 통해 카카오 회원 인증까지는 성공했으나, Local Storage에 토큰이 정상적으로 저장되지 않는 문제가 발생했다. 처음에는 CORS 문제인지, 인증 코드가 정상적으로 전달되지 않는 문제인지 원인을 찾기 어려웠다. 디버깅을 통해 API 응답을 분석하고, Spring Security에서 CORS 정책을 수정했으며, React의 useEffect() 타이밍을 조정하여 문제를 해결했다. 또한, window.history.replaceState()를 사용해 OAuth 인증 후 URL에서 인증 코드가 중복 요청되는 문제를 방지했다.

또한, 게임 데이터 저장 방식에서도 개선이 필요했다. 초기에 플레이어의 스킬 업그레이드와 경험치가 즉시 DB에 반영되지 않아, 스테이지 클리어 후 데이터가 올바르게 저장되지 않는 문제가 있었다. API 요청 구조가 불명확하여, 프론트엔드에서 데이터를 어떤 방식으로 저장해야 하는지 혼란이 발생하기도 했다. 이 문제를 해결하기 위해, 프론트엔드에서 메모리에 데이터를 저장하고, 스테이지 클리어 시 일괄적으로 DB에 반영하는 방식으로 변경했다. API 요청 구조를 개선하여 불필요한 데이터 전송을 줄이고, JSON 응답 구조를 명확히 정의하여 API 연동 문제를 해결했다.

프론트엔드에서도 UI 문제를 해결해야 했다. 상점 UI가 로드되지 않는 문제가 발생했는데, 다른 js와의 충돌 때문이었다. Pixi.js 컨테이너가 활성화된 상태에서 상점 UI가 렌더링되면서, 게임 화면이 덮어씌워지는 문제가 발생한 것이다. 이를 해결하기 위해, 상점에 진입하면 Pixi 컨테이너를 display: none; 처리하고, 상점에서 나가면 다시 활성화하는 방식으로 UI를 개선했다. 또한, 아이템 데이터가 로드되기 전에 빈 화면이 표시되는 문제도 있었기 때문에, useEffect()를 활용해 로딩 상태를 추가하고, 아이템 데이터가 준비되었을 때만 UI를 렌더링하도록 수정했다.


## 📬 문의
- Contact: junejjk@gmail.com
